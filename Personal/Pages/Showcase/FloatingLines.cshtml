@page
@model Personal.Pages.Showcase.FloatingLinesModel
@{
    Layout = null;
}
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Floating Lines — Style Lab</title>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800;900&display=swap" rel="stylesheet" />
    <style>
        *, *::before, *::after { margin: 0; padding: 0; box-sizing: border-box; }
        html, body { width: 100%; height: 100%; overflow: hidden; background: #000; font-family: 'Inter', sans-serif; }

        #scene-container {
            position: fixed; inset: 0; width: 100%; height: 100%;
            mix-blend-mode: screen;
        }
        #scene-container canvas { display: block; width: 100% !important; height: 100% !important; }

        .fl-back {
            position: fixed; top: 1.25rem; left: 1.25rem; z-index: 10;
            display: inline-flex; align-items: center; gap: 0.5rem;
            padding: 0.55rem 1.1rem; border-radius: 99px;
            background: rgba(255,255,255,0.06); border: 1px solid rgba(255,255,255,0.12);
            color: rgba(255,255,255,0.7); font-size: 0.85rem; font-weight: 600;
            text-decoration: none; backdrop-filter: blur(12px); transition: all 0.25s ease;
        }
        .fl-back:hover { background: rgba(233,71,245,0.1); border-color: rgba(233,71,245,0.35); color: #e947f5; }
        .fl-back svg { width: 16px; height: 16px; }

        .fl-overlay {
            position: fixed; inset: 0; z-index: 10;
            display: flex; align-items: center;
            padding: 0 5vw;
            pointer-events: none;
        }
        .fl-content {
            max-width: 620px;
        }

        .fl-label {
            display: inline-flex; align-items: center; gap: 8px;
            font-size: 0.65rem; font-weight: 500; text-transform: uppercase;
            letter-spacing: 0.2em; color: rgba(233,71,245,0.7); margin-bottom: 20px;
        }
        .fl-label-line { width: 32px; height: 1px; background: rgba(233,71,245,0.3); }

        .fl-heading {
            font-size: clamp(2.8rem, 5.5vw, 4.8rem); font-weight: 200;
            line-height: 1.1; letter-spacing: -0.04em; color: #fff; margin-bottom: 20px;
        }
        .fl-heading strong { font-weight: 700; }
        .fl-heading em {
            font-style: normal;
            background: linear-gradient(90deg, #e947f5, #2f4ba2);
            -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text;
        }

        .fl-desc {
            font-size: 1rem; color: rgba(255,255,255,0.4); line-height: 1.75;
            font-weight: 300; max-width: 480px; margin-bottom: 32px;
        }

        .fl-pills { display: flex; gap: 10px; flex-wrap: wrap; margin-bottom: 32px; }
        .fl-pill {
            padding: 8px 18px; border-radius: 50px;
            background: rgba(255,255,255,0.03); border: 1px solid rgba(255,255,255,0.07);
            font-size: 0.78rem; color: rgba(255,255,255,0.5); font-weight: 400;
            backdrop-filter: blur(8px);
            transition: all 0.3s;
        }
        .fl-pill:hover { background: rgba(233,71,245,0.06); border-color: rgba(233,71,245,0.2); color: rgba(233,71,245,0.8); }

        .fl-actions { display: flex; align-items: center; gap: 24px; pointer-events: auto; }
        .fl-btn-main {
            padding: 14px 34px; border-radius: 50px; border: none;
            background: linear-gradient(135deg, #e947f5, #2f4ba2);
            color: #fff; font-weight: 600; font-size: 0.92rem; font-family: inherit;
            cursor: pointer; transition: all 0.3s;
            box-shadow: 0 4px 24px rgba(233,71,245,0.2);
        }
        .fl-btn-main:hover { transform: scale(1.06); box-shadow: 0 8px 36px rgba(233,71,245,0.35); }
        .fl-link {
            display: inline-flex; align-items: center; gap: 6px;
            font-size: 0.88rem; color: rgba(255,255,255,0.5); font-weight: 500;
            text-decoration: none; transition: color 0.3s; cursor: pointer;
        }
        .fl-link:hover { color: #e947f5; }
        .fl-link svg { width: 16px; height: 16px; transition: transform 0.3s; }
        .fl-link:hover svg { transform: translateX(4px); }

        /* Right side stat column */
        .fl-stats {
            position: fixed; top: 50%; right: 5vw; z-index: 10;
            transform: translateY(-50%); display: flex; flex-direction: column; gap: 32px;
            pointer-events: none;
        }
        .fl-stat { text-align: right; }
        .fl-stat-value {
            font-size: 2.5rem; font-weight: 800; letter-spacing: -0.04em;
            background: linear-gradient(180deg, #fff, rgba(255,255,255,0.4));
            -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text;
        }
        .fl-stat-label { font-size: 0.72rem; color: rgba(255,255,255,0.25); letter-spacing: 0.06em; font-weight: 400; margin-top: 2px; }

        .fl-cursor-hint {
            position: fixed; bottom: 2.5rem; right: 5vw; z-index: 10;
            font-size: 0.7rem; color: rgba(255,255,255,0.2); letter-spacing: 0.1em;
        }

        /* Animations */
        @@keyframes flSlideUp { from { opacity: 0; transform: translateY(30px); } to { opacity: 1; transform: translateY(0); } }
        @@keyframes flFadeIn { from { opacity: 0; } to { opacity: 1; } }
        .fl-anim { animation: flSlideUp 0.7s ease-out forwards; opacity: 0; }
        .fl-anim-fade { animation: flFadeIn 0.8s ease-out forwards; opacity: 0; }
        .fl-d1 { animation-delay: 0.1s; } .fl-d2 { animation-delay: 0.25s; } .fl-d3 { animation-delay: 0.4s; }
        .fl-d4 { animation-delay: 0.55s; } .fl-d5 { animation-delay: 0.7s; } .fl-d6 { animation-delay: 0.85s; }
        .fl-d7 { animation-delay: 1s; } .fl-d8 { animation-delay: 1.15s; }

        @@media (max-width: 900px) {
            .fl-overlay { align-items: center; padding: 2rem; text-align: center; }
            .fl-content { max-width: 100%; }
            .fl-desc { margin-left: auto; margin-right: auto; }
            .fl-pills { justify-content: center; }
            .fl-actions { justify-content: center; }
            .fl-stats { display: none; }
            .fl-cursor-hint { display: none; }
        }
    </style>
</head>
<body>
    <a class="fl-back" href="/Showcase/LandingPages">
        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M15.75 19.5L8.25 12l7.5-7.5"/></svg>
        Back
    </a>
    <div id="scene-container"></div>

    <div class="fl-overlay">
        <div class="fl-content">
            <div class="fl-label fl-anim fl-d1">
                <span class="fl-label-line"></span>
                <span>Design Studio</span>
            </div>

            <h1 class="fl-heading fl-anim fl-d2">
                We craft <strong>digital<br>experiences</strong> that<br>feel <em>alive.</em>
            </h1>

            <p class="fl-desc fl-anim fl-d3">
                A boutique studio at the intersection of design, motion, and
                technology. We build brands that move people — literally.
            </p>

            <div class="fl-pills fl-anim fl-d4">
                <span class="fl-pill">Brand Identity</span>
                <span class="fl-pill">Motion Design</span>
                <span class="fl-pill">WebGL</span>
                <span class="fl-pill">Interactive</span>
            </div>

            <div class="fl-actions fl-anim fl-d5">
                <button class="fl-btn-main" onclick="void(0)">Start a Project</button>
                <a class="fl-link" onclick="return false;" href="#">
                    View Work
                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M13.5 4.5L21 12m0 0l-7.5 7.5M21 12H3"/></svg>
                </a>
            </div>
        </div>
    </div>

    <div class="fl-stats">
        <div class="fl-stat fl-anim-fade fl-d6">
            <div class="fl-stat-value">12+</div>
            <div class="fl-stat-label">Years of Craft</div>
        </div>
        <div class="fl-stat fl-anim-fade fl-d7">
            <div class="fl-stat-value">240</div>
            <div class="fl-stat-label">Projects Shipped</div>
        </div>
        <div class="fl-stat fl-anim-fade fl-d8">
            <div class="fl-stat-value">38</div>
            <div class="fl-stat-label">Awards Won</div>
        </div>
    </div>

    <div class="fl-cursor-hint fl-anim-fade fl-d8">Move cursor to bend the field ↗</div>

    <script type="module">
    import {
        Scene, OrthographicCamera, WebGLRenderer,
        PlaneGeometry, Mesh, ShaderMaterial,
        Vector3, Vector2, Clock
    } from 'https://esm.sh/three@0.170.0';

    const vertexShader = `
    precision highp float;
    void main() {
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    }`;

    const fragmentShader = `
    precision highp float;

    uniform float iTime;
    uniform vec3  iResolution;
    uniform float animationSpeed;

    uniform bool enableTop;
    uniform bool enableMiddle;
    uniform bool enableBottom;

    uniform int topLineCount;
    uniform int middleLineCount;
    uniform int bottomLineCount;

    uniform float topLineDistance;
    uniform float middleLineDistance;
    uniform float bottomLineDistance;

    uniform vec3 topWavePosition;
    uniform vec3 middleWavePosition;
    uniform vec3 bottomWavePosition;

    uniform vec2 iMouse;
    uniform bool interactive;
    uniform float bendRadius;
    uniform float bendStrength;
    uniform float bendInfluence;

    uniform bool parallax;
    uniform float parallaxStrength;
    uniform vec2 parallaxOffset;

    uniform vec3 lineGradient[8];
    uniform int lineGradientCount;

    const vec3 BLACK = vec3(0.0);
    const vec3 PINK  = vec3(233.0, 71.0, 245.0) / 255.0;
    const vec3 BLUE  = vec3(47.0,  75.0, 162.0) / 255.0;

    mat2 rotate(float r) {
        return mat2(cos(r), sin(r), -sin(r), cos(r));
    }

    vec3 background_color(vec2 uv) {
        vec3 col = vec3(0.0);
        float y = sin(uv.x - 0.2) * 0.3 - 0.1;
        float m = uv.y - y;
        col += mix(BLUE, BLACK, smoothstep(0.0, 1.0, abs(m)));
        col += mix(PINK, BLACK, smoothstep(0.0, 1.0, abs(m - 0.8)));
        return col * 0.5;
    }

    vec3 getLineColor(float t, vec3 baseColor) {
        if (lineGradientCount <= 0) return baseColor;
        vec3 gradientColor;
        if (lineGradientCount == 1) {
            gradientColor = lineGradient[0];
        } else {
            float clampedT = clamp(t, 0.0, 0.9999);
            float scaled = clampedT * float(lineGradientCount - 1);
            int idx = int(floor(scaled));
            float f = fract(scaled);
            int idx2 = min(idx + 1, lineGradientCount - 1);
            gradientColor = mix(lineGradient[idx], lineGradient[idx2], f);
        }
        return gradientColor * 0.5;
    }

    float wave(vec2 uv, float offset, vec2 screenUv, vec2 mouseUv, bool shouldBend) {
        float time = iTime * animationSpeed;
        float x_offset   = offset;
        float x_movement = time * 0.1;
        float amp        = sin(offset + time * 0.2) * 0.3;
        float y          = sin(uv.x + x_offset + x_movement) * amp;

        if (shouldBend) {
            vec2 d = screenUv - mouseUv;
            float influence = exp(-dot(d, d) * bendRadius);
            float bendOffset = (mouseUv.y - screenUv.y) * influence * bendStrength * bendInfluence;
            y += bendOffset;
        }

        float m = uv.y - y;
        return 0.0175 / max(abs(m) + 0.01, 1e-3) + 0.01;
    }

    void mainImage(out vec4 fragColor, in vec2 fragCoord) {
        vec2 baseUv = (2.0 * fragCoord - iResolution.xy) / iResolution.y;
        baseUv.y *= -1.0;
        if (parallax) baseUv += parallaxOffset;

        vec3 col = vec3(0.0);
        vec3 b = lineGradientCount > 0 ? vec3(0.0) : background_color(baseUv);

        vec2 mouseUv = vec2(0.0);
        if (interactive) {
            mouseUv = (2.0 * iMouse - iResolution.xy) / iResolution.y;
            mouseUv.y *= -1.0;
        }

        if (enableBottom) {
            for (int i = 0; i < bottomLineCount; ++i) {
                float fi = float(i);
                float t = fi / max(float(bottomLineCount - 1), 1.0);
                vec3 lineCol = getLineColor(t, b);
                float angle = bottomWavePosition.z * log(length(baseUv) + 1.0);
                vec2 ruv = baseUv * rotate(angle);
                col += lineCol * wave(
                    ruv + vec2(bottomLineDistance * fi + bottomWavePosition.x, bottomWavePosition.y),
                    1.5 + 0.2 * fi, baseUv, mouseUv, interactive
                ) * 0.2;
            }
        }

        if (enableMiddle) {
            for (int i = 0; i < middleLineCount; ++i) {
                float fi = float(i);
                float t = fi / max(float(middleLineCount - 1), 1.0);
                vec3 lineCol = getLineColor(t, b);
                float angle = middleWavePosition.z * log(length(baseUv) + 1.0);
                vec2 ruv = baseUv * rotate(angle);
                col += lineCol * wave(
                    ruv + vec2(middleLineDistance * fi + middleWavePosition.x, middleWavePosition.y),
                    2.0 + 0.15 * fi, baseUv, mouseUv, interactive
                );
            }
        }

        if (enableTop) {
            for (int i = 0; i < topLineCount; ++i) {
                float fi = float(i);
                float t = fi / max(float(topLineCount - 1), 1.0);
                vec3 lineCol = getLineColor(t, b);
                float angle = topWavePosition.z * log(length(baseUv) + 1.0);
                vec2 ruv = baseUv * rotate(angle);
                ruv.x *= -1.0;
                col += lineCol * wave(
                    ruv + vec2(topLineDistance * fi + topWavePosition.x, topWavePosition.y),
                    1.0 + 0.2 * fi, baseUv, mouseUv, interactive
                ) * 0.1;
            }
        }

        fragColor = vec4(col, 1.0);
    }

    void main() {
        vec4 color = vec4(0.0);
        mainImage(color, gl_FragCoord.xy);
        gl_FragColor = color;
    }`;

    // ---- Config ----
    const animationSpeed = 1;
    const enabledWaves = ['top', 'middle', 'bottom'];
    const topLineCount = 6, middleLineCount = 6, bottomLineCount = 6;
    const topLineDistance = 0.05, middleLineDistance = 0.05, bottomLineDistance = 0.05;
    const topWavePos    = new Vector3(10.0, 0.5, -0.4);
    const middleWavePos = new Vector3(5.0,  0.0,  0.2);
    const bottomWavePos = new Vector3(2.0, -0.7,  0.4);
    const bendRadius = 5.0, bendStrength = -0.5, mouseDamping = 0.05;
    const parallaxStrength = 0.2;
    const MAX_GRADIENT_STOPS = 8;

    // ---- Setup ----
    const container = document.getElementById('scene-container');
    const scene = new Scene();
    const camera = new OrthographicCamera(-1, 1, 1, -1, 0, 1);
    camera.position.z = 1;

    const renderer = new WebGLRenderer({ antialias: true, alpha: false });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
    renderer.domElement.style.width = '100%';
    renderer.domElement.style.height = '100%';
    container.appendChild(renderer.domElement);

    const uniforms = {
        iTime:              { value: 0 },
        iResolution:        { value: new Vector3(1, 1, 1) },
        animationSpeed:     { value: animationSpeed },
        enableTop:          { value: true },
        enableMiddle:       { value: true },
        enableBottom:       { value: true },
        topLineCount:       { value: topLineCount },
        middleLineCount:    { value: middleLineCount },
        bottomLineCount:    { value: bottomLineCount },
        topLineDistance:     { value: topLineDistance },
        middleLineDistance:  { value: middleLineDistance },
        bottomLineDistance:  { value: bottomLineDistance },
        topWavePosition:    { value: topWavePos },
        middleWavePosition: { value: middleWavePos },
        bottomWavePosition: { value: bottomWavePos },
        iMouse:             { value: new Vector2(-1000, -1000) },
        interactive:        { value: true },
        bendRadius:         { value: bendRadius },
        bendStrength:       { value: bendStrength },
        bendInfluence:      { value: 0 },
        parallax:           { value: true },
        parallaxStrength:   { value: parallaxStrength },
        parallaxOffset:     { value: new Vector2(0, 0) },
        lineGradient:       { value: Array.from({ length: MAX_GRADIENT_STOPS }, () => new Vector3(1, 1, 1)) },
        lineGradientCount:  { value: 0 }
    };

    const material = new ShaderMaterial({ uniforms, vertexShader, fragmentShader });
    const geometry = new PlaneGeometry(2, 2);
    scene.add(new Mesh(geometry, material));

    const clock = new Clock();
    const targetMouse   = new Vector2(-1000, -1000);
    const currentMouse  = new Vector2(-1000, -1000);
    let   targetInfluence  = 0, currentInfluence  = 0;
    const targetParallax   = new Vector2(0, 0);
    const currentParallax  = new Vector2(0, 0);

    function setSize() {
        const w = container.clientWidth || 1;
        const h = container.clientHeight || 1;
        renderer.setSize(w, h, false);
        uniforms.iResolution.value.set(renderer.domElement.width, renderer.domElement.height, 1);
    }
    setSize();
    window.addEventListener('resize', setSize);

    renderer.domElement.addEventListener('pointermove', e => {
        const rect = renderer.domElement.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        const dpr = renderer.getPixelRatio();
        targetMouse.set(x * dpr, (rect.height - y) * dpr);
        targetInfluence = 1.0;
        const cx = rect.width / 2, cy = rect.height / 2;
        targetParallax.set(((x - cx) / rect.width) * parallaxStrength, -((y - cy) / rect.height) * parallaxStrength);
    });
    renderer.domElement.addEventListener('pointerleave', () => { targetInfluence = 0; });

    function loop() {
        uniforms.iTime.value = clock.getElapsedTime();
        currentMouse.lerp(targetMouse, mouseDamping);
        uniforms.iMouse.value.copy(currentMouse);
        currentInfluence += (targetInfluence - currentInfluence) * mouseDamping;
        uniforms.bendInfluence.value = currentInfluence;
        currentParallax.lerp(targetParallax, mouseDamping);
        uniforms.parallaxOffset.value.copy(currentParallax);
        renderer.render(scene, camera);
        requestAnimationFrame(loop);
    }
    loop();
    </script>
</body>
</html>
