@page
@model Personal.Pages.Showcase.LightPillarModel
@{
    Layout = null;
}
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Light Pillar — Style Lab</title>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800;900&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet" />
    <style>
        *, *::before, *::after { margin: 0; padding: 0; box-sizing: border-box; }
        html, body { width: 100%; height: 100%; overflow: hidden; background: #000; font-family: 'Inter', sans-serif; }

        /* Canvas container */
        #pillar-container {
            position: fixed; inset: 0; width: 100%; height: 100%;
            mix-blend-mode: screen;
            opacity: 0.55;
        }
        #pillar-container canvas { display: block; width: 100% !important; height: 100% !important; }

        /* Back button */
        .lp-back {
            position: fixed; top: 1.25rem; left: 1.25rem; z-index: 20;
            display: inline-flex; align-items: center; gap: 0.5rem;
            padding: 0.55rem 1.1rem; border-radius: 99px;
            background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.08);
            color: rgba(255,255,255,0.6); font-size: 0.85rem; font-weight: 600;
            text-decoration: none; backdrop-filter: blur(12px); transition: all 0.25s ease;
        }
        .lp-back:hover { background: rgba(82,39,255,0.12); border-color: rgba(82,39,255,0.3); color: #a78bfa; }
        .lp-back svg { width: 16px; height: 16px; }

        /* Dark scrim behind content for readability */
        .lp-scrim {
            position: fixed; inset: 0; z-index: 5; pointer-events: none;
            background: radial-gradient(ellipse at 50% 50%, rgba(0,0,0,0.45) 0%, rgba(0,0,0,0.65) 60%, rgba(0,0,0,0.8) 100%);
        }

        /* ===== Hero overlay ===== */
        .lp-overlay {
            position: fixed; inset: 0; z-index: 10;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            pointer-events: none; padding: 2rem;
        }
        .lp-hero { max-width: 760px; text-align: center; }

        /* Badge */
        .lp-badge {
            display: inline-flex; align-items: center; gap: 8px;
            padding: 7px 18px; border-radius: 50px;
            background: rgba(82,39,255,0.12); border: 1px solid rgba(82,39,255,0.2);
            backdrop-filter: blur(12px);
            font-size: 0.68rem; font-weight: 500; letter-spacing: 0.1em; text-transform: uppercase;
            color: rgba(167,139,250,0.95); margin-bottom: 28px;
        }
        .lp-badge-dot {
            width: 5px; height: 5px; border-radius: 50%;
            background: #a78bfa; animation: lp-dot-pulse 2s ease-in-out infinite;
        }
        @@keyframes lp-dot-pulse { 0%,100% { opacity: 1; } 50% { opacity: 0.25; } }

        /* Title */
        .lp-title {
            font-size: clamp(2.8rem, 6vw, 5rem); font-weight: 900;
            line-height: 1.06; letter-spacing: -0.04em; margin-bottom: 22px;
        }
        .lp-title-line1 {
            display: block; color: #fff;
            text-shadow: 0 2px 20px rgba(0,0,0,0.6), 0 0 40px rgba(0,0,0,0.3);
        }
        .lp-title-line2 {
            display: block;
            background: linear-gradient(90deg, #a78bfa, #FF9FFC, #f0abfc);
            -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text;
            filter: drop-shadow(0 2px 16px rgba(0,0,0,0.5));
        }

        /* Subtitle */
        .lp-subtitle {
            font-size: clamp(1rem, 1.5vw, 1.12rem); color: rgba(255,255,255,0.55);
            line-height: 1.75; font-weight: 400; max-width: 560px; margin: 0 auto 36px;
            text-shadow: 0 1px 12px rgba(0,0,0,0.7), 0 0 30px rgba(0,0,0,0.4);
        }

        /* CTA row */
        .lp-cta-row {
            display: flex; justify-content: center; gap: 14px; flex-wrap: wrap;
            pointer-events: auto; margin-bottom: 44px;
        }
        .lp-btn-primary {
            padding: 15px 36px; border-radius: 14px; border: none;
            background: linear-gradient(135deg, #5227FF, #a78bfa);
            color: #fff; font-weight: 700; font-size: 0.95rem; font-family: inherit;
            cursor: pointer; transition: all 0.3s;
            box-shadow: 0 4px 28px rgba(82,39,255,0.3);
        }
        .lp-btn-primary:hover { transform: scale(1.06); box-shadow: 0 8px 40px rgba(82,39,255,0.45); }
        .lp-btn-secondary {
            padding: 15px 36px; border-radius: 14px;
            background: rgba(255,255,255,0.04); border: 1px solid rgba(255,255,255,0.1);
            color: #d4d4d8; font-weight: 600; font-size: 0.95rem; font-family: inherit;
            cursor: pointer; backdrop-filter: blur(8px); transition: all 0.3s;
        }
        .lp-btn-secondary:hover { background: rgba(255,255,255,0.08); border-color: rgba(255,255,255,0.2); }

        /* Metrics strip */
        .lp-metrics {
            display: flex; justify-content: center; gap: 40px; flex-wrap: wrap;
            pointer-events: auto;
        }
        .lp-metric { text-align: center; }
        .lp-metric-value {
            font-size: 1.5rem; font-weight: 800; letter-spacing: -0.03em;
            background: linear-gradient(180deg, #fff, rgba(255,255,255,0.5));
            -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text;
            filter: drop-shadow(0 1px 10px rgba(0,0,0,0.6));
        }
        .lp-metric-label {
            font-size: 0.68rem; color: rgba(255,255,255,0.35); margin-top: 3px;
            letter-spacing: 0.04em; font-weight: 400;
            text-shadow: 0 1px 8px rgba(0,0,0,0.6);
        }
        .lp-metric-sep {
            width: 1px; height: 36px; background: rgba(255,255,255,0.06);
            align-self: center;
        }

        /* Trust row */
        .lp-trust {
            display: flex; align-items: center; justify-content: center; gap: 24px;
            flex-wrap: wrap; margin-top: 48px; opacity: 0.3;
        }
        .lp-trust-label {
            font-size: 0.62rem; font-weight: 500; text-transform: uppercase;
            letter-spacing: 0.12em; color: rgba(255,255,255,0.4); margin-right: 8px;
        }
        .lp-trust-logo {
            font-size: 0.78rem; font-weight: 700; letter-spacing: 0.04em;
            color: rgba(255,255,255,0.55); text-transform: uppercase;
        }
        .lp-trust-dot { width: 3px; height: 3px; border-radius: 50%; background: rgba(255,255,255,0.12); }

        /* Animations */
        @@keyframes lpFadeUp { from { opacity: 0; transform: translateY(30px); } to { opacity: 1; transform: translateY(0); } }
        @@keyframes lpBlurIn { from { opacity: 0; filter: blur(16px); transform: scale(1.04); } to { opacity: 1; filter: blur(0px); transform: scale(1); } }
        @@keyframes lpFadeIn { from { opacity: 0; } to { opacity: 1; } }
        .lp-anim-up { animation: lpFadeUp 0.7s ease-out forwards; opacity: 0; }
        .lp-anim-blur { animation: lpBlurIn 0.9s ease-out forwards; opacity: 0; }
        .lp-anim-fade { animation: lpFadeIn 0.8s ease-out forwards; opacity: 0; }
        .lp-d1 { animation-delay: 0.15s; } .lp-d2 { animation-delay: 0.3s; }
        .lp-d3 { animation-delay: 0.5s; } .lp-d4 { animation-delay: 0.7s; }
        .lp-d5 { animation-delay: 0.9s; } .lp-d6 { animation-delay: 1.1s; }
        .lp-d7 { animation-delay: 1.3s; }

        @@media (max-width: 640px) {
            .lp-cta-row { flex-direction: column; align-items: center; }
            .lp-metrics { gap: 20px; }
            .lp-metric-sep { display: none; }
            .lp-trust { gap: 14px; }
        }
    </style>
</head>
<body>
    <a class="lp-back" href="/Showcase/LandingPages">
        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M15.75 19.5L8.25 12l7.5-7.5"/></svg>
        Back
    </a>

    <!-- WebGL background -->
    <div id="pillar-container"></div>
    <div class="lp-scrim"></div>

    <!-- Hero content -->
    <div class="lp-overlay">
        <div class="lp-hero">
            <div class="lp-badge lp-anim-up lp-d1">
                <span class="lp-badge-dot"></span>
                <span>Announcing Lumina v4.0</span>
            </div>

            <h1 class="lp-title lp-anim-blur lp-d2">
                <span class="lp-title-line1">Intelligence that</span>
                <span class="lp-title-line2">illuminates.</span>
            </h1>

            <p class="lp-subtitle lp-anim-up lp-d3">
                Foundation models built for the enterprise. Fine-tune, deploy,
                and scale AI that understands your domain — private, fast, and endlessly adaptable.
            </p>

            <div class="lp-cta-row lp-anim-up lp-d4">
                <button class="lp-btn-primary" onclick="void(0)">Try Lumina Free</button>
                <button class="lp-btn-secondary" onclick="void(0)">Talk to Sales</button>
            </div>

            <div class="lp-metrics lp-anim-fade lp-d5">
                <div class="lp-metric">
                    <div class="lp-metric-value">4.2T</div>
                    <div class="lp-metric-label">Parameters</div>
                </div>
                <div class="lp-metric-sep"></div>
                <div class="lp-metric">
                    <div class="lp-metric-value">14ms</div>
                    <div class="lp-metric-label">Avg Inference</div>
                </div>
                <div class="lp-metric-sep"></div>
                <div class="lp-metric">
                    <div class="lp-metric-value">99.97%</div>
                    <div class="lp-metric-label">Accuracy (MMLU)</div>
                </div>
                <div class="lp-metric-sep"></div>
                <div class="lp-metric">
                    <div class="lp-metric-value">SOC 2</div>
                    <div class="lp-metric-label">Certified</div>
                </div>
            </div>

            <div class="lp-trust lp-anim-fade lp-d6">
                <span class="lp-trust-label">Trusted by</span>
                <span class="lp-trust-logo">Stripe</span>
                <span class="lp-trust-dot"></span>
                <span class="lp-trust-logo">Figma</span>
                <span class="lp-trust-dot"></span>
                <span class="lp-trust-logo">Linear</span>
                <span class="lp-trust-dot"></span>
                <span class="lp-trust-logo">Vercel</span>
                <span class="lp-trust-dot"></span>
                <span class="lp-trust-logo">Notion</span>
            </div>
        </div>
    </div>

    <script type="module">
    import * as THREE from 'https://esm.sh/three@0.163.0';

    (function () {
        const container = document.getElementById('pillar-container');
        if (!container) return;

        const width = container.clientWidth;
        const height = container.clientHeight;

        // Config
        const topColor = '#5227FF';
        const bottomColor = '#FF9FFC';
        const intensity = 0.75;
        const rotationSpeed = 0.3;
        const glowAmount = 0.003;
        const pillarWidth = 3.0;
        const pillarHeight = 0.4;
        const noiseIntensity = 0.5;
        const pillarRotation = 0;

        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        const isLowEnd = isMobile || (navigator.hardwareConcurrency && navigator.hardwareConcurrency <= 4);

        let quality = 'high';
        if (isLowEnd) quality = 'medium';
        if (isMobile) quality = 'low';

        const qualitySettings = {
            low:    { iterations: 24, waveIterations: 1, pixelRatio: 0.5,  precision: 'mediump', stepMult: 1.5 },
            medium: { iterations: 40, waveIterations: 2, pixelRatio: 0.65, precision: 'mediump', stepMult: 1.2 },
            high:   { iterations: 80, waveIterations: 4, pixelRatio: Math.min(window.devicePixelRatio, 2), precision: 'highp', stepMult: 1.0 }
        };
        const S = qualitySettings[quality];

        let renderer;
        try {
            renderer = new THREE.WebGLRenderer({
                antialias: false,
                alpha: true,
                powerPreference: quality === 'high' ? 'high-performance' : 'low-power',
                precision: S.precision,
                stencil: false,
                depth: false
            });
        } catch (e) { return; }

        renderer.setSize(width, height);
        renderer.setPixelRatio(S.pixelRatio);
        container.appendChild(renderer.domElement);

        const scene = new THREE.Scene();
        const camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);

        const parseColor = hex => {
            const c = new THREE.Color(hex);
            return new THREE.Vector3(c.r, c.g, c.b);
        };

        const pillarRotRad = (pillarRotation * Math.PI) / 180;

        const vertexShader = `
            varying vec2 vUv;
            void main() {
                vUv = uv;
                gl_Position = vec4(position, 1.0);
            }
        `;

        const fragmentShader = `
            precision ${S.precision} float;

            uniform float uTime;
            uniform vec2 uResolution;
            uniform vec2 uMouse;
            uniform vec3 uTopColor;
            uniform vec3 uBottomColor;
            uniform float uIntensity;
            uniform float uGlowAmount;
            uniform float uPillarWidth;
            uniform float uPillarHeight;
            uniform float uNoiseIntensity;
            uniform float uRotCos;
            uniform float uRotSin;
            uniform float uPillarRotCos;
            uniform float uPillarRotSin;
            uniform float uWaveSin;
            uniform float uWaveCos;
            varying vec2 vUv;

            const float STEP_MULT = ${S.stepMult.toFixed(1)};
            const int MAX_ITER = ${S.iterations};
            const int WAVE_ITER = ${S.waveIterations};

            void main() {
                vec2 uv = (vUv * 2.0 - 1.0) * vec2(uResolution.x / uResolution.y, 1.0);
                uv = vec2(uPillarRotCos * uv.x - uPillarRotSin * uv.y,
                           uPillarRotSin * uv.x + uPillarRotCos * uv.y);

                vec3 ro = vec3(0.0, 0.0, -10.0);
                vec3 rd = normalize(vec3(uv, 1.0));

                float rotC = uRotCos;
                float rotS = uRotSin;

                vec3 col = vec3(0.0);
                float t = 0.1;

                for (int i = 0; i < MAX_ITER; i++) {
                    vec3 p = ro + rd * t;
                    p.xz = vec2(rotC * p.x - rotS * p.z, rotS * p.x + rotC * p.z);

                    vec3 q = p;
                    q.y = p.y * uPillarHeight + uTime;

                    float freq = 1.0;
                    float amp = 1.0;
                    for (int j = 0; j < WAVE_ITER; j++) {
                        q.xz = vec2(uWaveCos * q.x - uWaveSin * q.z,
                                     uWaveSin * q.x + uWaveCos * q.z);
                        q += cos(q.zxy * freq - uTime * float(j) * 2.0) * amp;
                        freq *= 2.0;
                        amp *= 0.5;
                    }

                    float d = length(cos(q.xz)) - 0.2;
                    float bound = length(p.xz) - uPillarWidth;
                    float k = 4.0;
                    float h = max(k - abs(d - bound), 0.0);
                    d = max(d, bound) + h * h * 0.0625 / k;
                    d = abs(d) * 0.15 + 0.01;

                    float grad = clamp((15.0 - p.y) / 30.0, 0.0, 1.0);
                    col += mix(uBottomColor, uTopColor, grad) / d;

                    t += d * STEP_MULT;
                    if (t > 50.0) break;
                }

                float widthNorm = uPillarWidth / 3.0;
                col = tanh(col * uGlowAmount / widthNorm);
                col -= fract(sin(dot(gl_FragCoord.xy, vec2(12.9898, 78.233))) * 43758.5453) / 15.0 * uNoiseIntensity;

                gl_FragColor = vec4(col * uIntensity, 1.0);
            }
        `;

        const material = new THREE.ShaderMaterial({
            vertexShader,
            fragmentShader,
            uniforms: {
                uTime:          { value: 0 },
                uResolution:    { value: new THREE.Vector2(width, height) },
                uMouse:         { value: new THREE.Vector2(0, 0) },
                uTopColor:      { value: parseColor(topColor) },
                uBottomColor:   { value: parseColor(bottomColor) },
                uIntensity:     { value: intensity },
                uGlowAmount:    { value: glowAmount },
                uPillarWidth:   { value: pillarWidth },
                uPillarHeight:  { value: pillarHeight },
                uNoiseIntensity:{ value: noiseIntensity },
                uRotCos:        { value: 1.0 },
                uRotSin:        { value: 0.0 },
                uPillarRotCos:  { value: Math.cos(pillarRotRad) },
                uPillarRotSin:  { value: Math.sin(pillarRotRad) },
                uWaveSin:       { value: Math.sin(0.4) },
                uWaveCos:       { value: Math.cos(0.4) }
            },
            transparent: true,
            depthWrite: false,
            depthTest: false
        });

        const geometry = new THREE.PlaneGeometry(2, 2);
        scene.add(new THREE.Mesh(geometry, material));

        let time = 0;
        let lastFrame = performance.now();
        const targetFrame = quality === 'low' ? 1000 / 30 : 1000 / 60;

        function animate(now) {
            const dt = now - lastFrame;
            if (dt >= targetFrame) {
                time += 0.016 * rotationSpeed;
                material.uniforms.uTime.value = time;
                material.uniforms.uRotCos.value = Math.cos(time * 0.3);
                material.uniforms.uRotSin.value = Math.sin(time * 0.3);
                renderer.render(scene, camera);
                lastFrame = now - (dt % targetFrame);
            }
            requestAnimationFrame(animate);
        }
        requestAnimationFrame(animate);

        let resizeTimer = null;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimer);
            resizeTimer = setTimeout(() => {
                const w = container.clientWidth;
                const h = container.clientHeight;
                renderer.setSize(w, h);
                material.uniforms.uResolution.value.set(w, h);
            }, 150);
        }, { passive: true });
    })();
    </script>
</body>
</html>
