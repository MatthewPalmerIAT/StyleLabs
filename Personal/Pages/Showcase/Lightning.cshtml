@page
@model Personal.Pages.Showcase.LightningModel
@{
    Layout = null;
}
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Lightning — Style Lab</title>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700;900&display=swap" rel="stylesheet" />
    <style>
        *, *::before, *::after { margin: 0; padding: 0; box-sizing: border-box; }
        html, body { width: 100%; height: 100%; overflow: hidden; background: #000; font-family: 'Inter', sans-serif; }
        .lightning-canvas { width: 100%; height: 100%; position: absolute; top: 0; left: 0; display: block; }
        .lt-overlay {
            position: fixed; inset: 0; z-index: 2;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            pointer-events: none;
        }
        .lt-title {
            font-size: clamp(3rem, 8vw, 7rem); font-weight: 900; letter-spacing: 0.15em;
            color: #fff; text-shadow: 0 0 60px rgba(100,140,255,0.5), 0 0 120px rgba(80,100,220,0.25);
        }
        .lt-sub { font-size: 1rem; color: rgba(255,255,255,0.4); margin-top: 0.75rem; letter-spacing: 0.1em; }
        .lt-back {
            position: fixed; top: 1.25rem; left: 1.25rem; z-index: 10;
            display: inline-flex; align-items: center; gap: 0.5rem;
            padding: 0.55rem 1.1rem; border-radius: 99px;
            background: rgba(255,255,255,0.06); border: 1px solid rgba(255,255,255,0.12);
            color: rgba(255,255,255,0.7); font-size: 0.85rem; font-weight: 600;
            text-decoration: none; backdrop-filter: blur(12px); transition: all 0.25s ease;
        }
        .lt-back:hover { background: rgba(100,140,255,0.1); border-color: rgba(100,140,255,0.35); color: #8cabff; }
        .lt-back svg { width: 16px; height: 16px; }
    </style>
</head>
<body>
    <a class="lt-back" href="/Showcase/LandingPages">
        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M15.75 19.5L8.25 12l7.5-7.5"/></svg>
        Back
    </a>
    <canvas id="lightning-canvas" class="lightning-canvas"></canvas>
    <div class="lt-overlay">
        <h1 class="lt-title">LIGHTNING</h1>
        <p class="lt-sub">Pure WebGL shader — no libraries</p>
    </div>

    <script>
    (function () {
      const canvas = document.getElementById('lightning-canvas');
      if (!canvas) return;

      const hue = 230;
      const xOffset = 0;
      const speed = 1;
      const intensity = 1;
      const size = 1;

      const resizeCanvas = () => {
        canvas.width = canvas.clientWidth;
        canvas.height = canvas.clientHeight;
      };
      resizeCanvas();
      window.addEventListener('resize', resizeCanvas);

      const gl = canvas.getContext('webgl');
      if (!gl) { console.error('WebGL not supported'); return; }

      const vertexShaderSource = `
        attribute vec2 aPosition;
        void main() {
          gl_Position = vec4(aPosition, 0.0, 1.0);
        }
      `;

      const fragmentShaderSource = `
        precision mediump float;
        uniform vec2 iResolution;
        uniform float iTime;
        uniform float uHue;
        uniform float uXOffset;
        uniform float uSpeed;
        uniform float uIntensity;
        uniform float uSize;

        #define OCTAVE_COUNT 10

        vec3 hsv2rgb(vec3 c) {
            vec3 rgb = clamp(abs(mod(c.x * 6.0 + vec3(0.0,4.0,2.0), 6.0) - 3.0) - 1.0, 0.0, 1.0);
            return c.z * mix(vec3(1.0), rgb, c.y);
        }

        float hash11(float p) {
            p = fract(p * .1031);
            p *= p + 33.33;
            p *= p + p;
            return fract(p);
        }

        float hash12(vec2 p) {
            vec3 p3 = fract(vec3(p.xyx) * .1031);
            p3 += dot(p3, p3.yzx + 33.33);
            return fract((p3.x + p3.y) * p3.z);
        }

        mat2 rotate2d(float theta) {
            float c = cos(theta);
            float s = sin(theta);
            return mat2(c, -s, s, c);
        }

        float noise(vec2 p) {
            vec2 ip = floor(p);
            vec2 fp = fract(p);
            float a = hash12(ip);
            float b = hash12(ip + vec2(1.0, 0.0));
            float c = hash12(ip + vec2(0.0, 1.0));
            float d = hash12(ip + vec2(1.0, 1.0));
            vec2 t = smoothstep(0.0, 1.0, fp);
            return mix(mix(a, b, t.x), mix(c, d, t.x), t.y);
        }

        float fbm(vec2 p) {
            float value = 0.0;
            float amplitude = 0.5;
            for (int i = 0; i < OCTAVE_COUNT; ++i) {
                value += amplitude * noise(p);
                p *= rotate2d(0.45);
                p *= 2.0;
                amplitude *= 0.5;
            }
            return value;
        }

        void mainImage( out vec4 fragColor, in vec2 fragCoord ) {
            vec2 uv = fragCoord / iResolution.xy;
            uv = 2.0 * uv - 1.0;
            uv.x *= iResolution.x / iResolution.y;
            uv.x += uXOffset;

            uv += 2.0 * fbm(uv * uSize + 0.8 * iTime * uSpeed) - 1.0;

            float dist = abs(uv.x);
            vec3 baseColor = hsv2rgb(vec3(uHue / 360.0, 0.7, 0.8));
            vec3 col = baseColor * pow(mix(0.0, 0.07, hash11(iTime * uSpeed)) / dist, 1.0) * uIntensity;
            col = pow(col, vec3(1.0));
            fragColor = vec4(col, 1.0);
        }

        void main() {
            mainImage(gl_FragColor, gl_FragCoord.xy);
        }
      `;

      function compileShader(source, type) {
        const shader = gl.createShader(type);
        if (!shader) return null;
        gl.shaderSource(shader, source);
        gl.compileShader(shader);
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
          console.error('Shader compile error:', gl.getShaderInfoLog(shader));
          gl.deleteShader(shader);
          return null;
        }
        return shader;
      }

      const vertexShader = compileShader(vertexShaderSource, gl.VERTEX_SHADER);
      const fragmentShader = compileShader(fragmentShaderSource, gl.FRAGMENT_SHADER);
      if (!vertexShader || !fragmentShader) return;

      const program = gl.createProgram();
      if (!program) return;
      gl.attachShader(program, vertexShader);
      gl.attachShader(program, fragmentShader);
      gl.linkProgram(program);
      if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
        console.error('Program linking error:', gl.getProgramInfoLog(program));
        return;
      }
      gl.useProgram(program);

      const vertices = new Float32Array([-1, -1, 1, -1, -1, 1, -1, 1, 1, -1, 1, 1]);
      const vertexBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
      gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);

      const aPosition = gl.getAttribLocation(program, 'aPosition');
      gl.enableVertexAttribArray(aPosition);
      gl.vertexAttribPointer(aPosition, 2, gl.FLOAT, false, 0, 0);

      const iResolutionLocation = gl.getUniformLocation(program, 'iResolution');
      const iTimeLocation = gl.getUniformLocation(program, 'iTime');
      const uHueLocation = gl.getUniformLocation(program, 'uHue');
      const uXOffsetLocation = gl.getUniformLocation(program, 'uXOffset');
      const uSpeedLocation = gl.getUniformLocation(program, 'uSpeed');
      const uIntensityLocation = gl.getUniformLocation(program, 'uIntensity');
      const uSizeLocation = gl.getUniformLocation(program, 'uSize');

      const startTime = performance.now();
      function render() {
        resizeCanvas();
        gl.viewport(0, 0, canvas.width, canvas.height);
        gl.uniform2f(iResolutionLocation, canvas.width, canvas.height);
        gl.uniform1f(iTimeLocation, (performance.now() - startTime) / 1000.0);
        gl.uniform1f(uHueLocation, hue);
        gl.uniform1f(uXOffsetLocation, xOffset);
        gl.uniform1f(uSpeedLocation, speed);
        gl.uniform1f(uIntensityLocation, intensity);
        gl.uniform1f(uSizeLocation, size);
        gl.drawArrays(gl.TRIANGLES, 0, 6);
        requestAnimationFrame(render);
      }
      requestAnimationFrame(render);
    })();
    </script>
</body>
</html>
